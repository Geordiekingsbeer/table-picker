That is fantastic\! Having that $100\%$ working Admin code as the base is the best possible foundation for building the scheduling feature.

You are correct that the next step is integrating the Schedule Viewer we planned. We'll use the existing, perfected code and inject the date/time selection logic.

Here is the plan for integrating the **Schedule Viewer** into your robust Admin page:

1.  **New HTML:** Insert the Date/Time dropdowns and "Refresh Map" button.
2.  **JS Initialization:** Add functions to populate the time dropdown and set the default date.
3.  **Core Logic:** Update `loadTables()` to filter the map based on the selected date/time.

-----

## Complete Copy and Replace Code (Admin Page with Schedule Viewer)

This code replaces the entire file. It retains all your existing styling and functionality while adding the Schedule Viewer at the top.

\***Note on the Supabase Query:** The new `loadBookings()` function assumes you have a table named `premium_slots` where the host will log future manual bookings. You will need to implement this table.

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Admin – Drag Tables</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    body{
        font-family: Arial, Helvetica, sans-serif;
        background:#f7f7f7;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0; 
        padding: 20px 0;
    }

    /* Header container */
    h2 {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 700;
      color: #333;
      margin-bottom: 25px;
      flex-wrap: wrap;
      gap: 10px;
    }

    h2 .arrow {
      font-weight: 700;
      font-size: 24px;
      margin: 0 10px;
      color: #1976d2;
    }

    /* Buttons in header */
    h2 button {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      color: #fff;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }

    h2 button#save {
      background-color: #388e3c;
    }
    h2 button#rotate {
      background-color: #1976d2;
    }

    h2 button:hover {
      box-shadow: 0 6px 14px rgba(0,0,0,0.3);
      opacity: 0.95;
    }

    /* Schedule Controls Styling (New) */
    #schedule-controls {
      margin-bottom: 15px;
      padding: 10px;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      display: flex;
      align-items: center;
      gap: 15px;
    }
    #schedule-controls label {
      font-weight: 600;
      margin-right: 5px;
      font-size: 14px;
      color: #555;
    }
    #schedule-controls input, #schedule-controls select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #schedule-controls button {
      background: #555;
      color: #fff;
      padding: 8px 15px;
      font-weight: 600;
      box-shadow: none;
    }

    /* Floorplan container */
    #container-wrapper {
      display: flex;
      justify-content: center;
      width: 100%;
    }

    #container{
      width:480px;
      height:480px;
      border:1px solid #ccc;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      background:#fff;
    }

    @media (max-width: 500px) {
      h2 { font-size: 18px; }
      h2 button { padding: 8px 14px; font-size: 14px; }
    }
  </style>
</head>
<body>
  <h2>
    Drag tables <span class="arrow">→</span>
    <button id="save">Save layout</button>
    <button id="rotate">Rotate Table 90°</button>
  </h2>

    <div id="schedule-controls">
    <label for="booking-date">Date:</label>
    <input type="date" id="booking-date">
    
    <label for="booking-time">Time Slot:</label>
    <select id="booking-time"></select>
    
    <button id="view-schedule">Refresh Map</button>
  </div>
  
  <div id="container-wrapper">
      <div id="container"></div>
  </div>

  <script>
    // --- Supabase setup ---
    const supabaseUrl = 'https://Rrjvdabtqzkaomjuiref.supabase.co';
    const supabaseAnon = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJyanZkYWJ0cXprYW9tanVpcmVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkxNDM3MzQsImV4cCI6MjA3NDcxOTczNH0.wAEeowZ8Yc8K54jAxEbY-8-mM0OGciMmyz6fJb9Z1Qg';
    const _supa = supabase.createClient(supabaseUrl, supabaseAnon);

    const STAGE_WIDTH = 480;
    const STAGE_HEIGHT = 480;

    const stage = new Konva.Stage({ container:'container', width:STAGE_WIDTH, height:STAGE_HEIGHT });
    const backgroundLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    const layer = new Konva.Layer(); 
    stage.add(layer);

    let tables = [];
    let selectedGroup = null;
    const TABLE_COLOR = '#b7d7a8';
    const SEAT_COLOR = '#555';
    const TAKEN_COLOR = '#9e9e9e'; 

    let currentBookings = []; // Array to hold occupied slots for the viewed date/time
    const TURN_DURATION_MINUTES = 90; // Standard table turn time (90 minutes)

    // Helper function to convert time string (e.g., "18:00") to minutes for comparison
    const timeToMinutes = (time) => {
      const [hours, minutes] = time.split(':').map(Number);
      return hours * 60 + minutes;
    };

    // --- Initialization of Date and Time Controls ---

    function populateTimeDropdown() {
      const select = document.getElementById('booking-time');
      // Typical dinner service times, change as needed
      const slots = ["17:00", "17:30", "18:00", "18:30", "19:00", "19:30", "20:00", "20:30", "21:00", "21:30", "22:00"]; 
      
      slots.forEach(time => {
        const option = document.createElement('option');
        option.value = time;
        option.textContent = time;
        select.appendChild(option);
      });

      // Set default date to today and default time to the first slot
      const today = new Date().toISOString().split('T')[0];
      document.getElementById('booking-date').value = today;
      select.value = slots[2]; // Default to 6:00 PM
    }
    
    // --- Load Bookings for the Selected Time ---
    async function loadBookings(date, time) {
      const selectedMinutes = timeToMinutes(time);
      
      // *** ACTION REQUIRED: ASSUMING A NEW 'premium_slots' TABLE EXISTS ***
      const { data, error } = await _supa.from('premium_slots')
        .select('table_id, start_time, end_time')
        .eq('date', date); // Filter by the selected date
      
      if (error) { console.error('Error fetching bookings:', error); return []; }
      
      // Filter data locally to find slots that overlap with the selected time
      const blockedTableIds = data
        .filter(slot => {
          // If end_time is not logged, assume a standard duration for safety
          const slotStartMinutes = timeToMinutes(slot.start_time);
          const slotEndMinutes = slot.end_time ? timeToMinutes(slot.end_time) : slotStartMinutes + TURN_DURATION_MINUTES;
          
          // Check for overlap: slot starts before view ends AND slot ends after view starts
          // The view time is assumed to be the start of the reservation (e.g., 18:00).
          return slotStartMinutes < selectedMinutes + TURN_DURATION_MINUTES && slotEndMinutes > selectedMinutes;
        })
        .map(b => b.table_id);
      
      return blockedTableIds; 
    }

    // --- Main Initialization Functions ---

    function loadBackground(callback) {
      const imageObj = new Image();
      imageObj.onload = function() {
        const floorplan = new Konva.Image({ x: 0, y: 0, image: imageObj, width: STAGE_WIDTH, height: STAGE_HEIGHT });
        backgroundLayer.add(floorplan);
        backgroundLayer.draw();
        if (callback) callback();
      };
      imageObj.src = 'floorplan.png';
    }

    async function loadTables() {
      layer.destroyChildren(); // Clear existing tables before redrawing

      const date = document.getElementById('booking-date').value;
      const time = document.getElementById('booking-time').value;

      // Get the list of table IDs that are blocked for the current view time
      const blockedTableIds = await loadBookings(date, time); 

      // 1. Load table base layout data
      const { data, error } = await _supa.from('tables').select('*, rotation').order('id');
      if(error){ console.error(error); alert('Error loading tables'); return; }
      tables = data;

      // 2. Draw tables, applying color based on time context
      tables.forEach(t => {
        const group = drawTable(t, blockedTableIds.includes(t.id)); // Pass block status
        const tableRect = group.findOne('.main-table');
        
        group.offset({ x: tableRect.width()/2, y: tableRect.height()/2 });
        group.x(t.x + tableRect.width()/2);
        group.y(t.y + tableRect.height()/2);
        group.rotation(t.rotation || 0); 
      });
      layer.draw();
    }

    // --- Draw Table with Block Status ---

    function drawTable(t, isBlocked){
      const group = new Konva.Group({ x:t.x, y:t.y, id:'g-'+t.id, draggable:true });
      layer.add(group);

      const tableRect = new Konva.Rect({ 
        width:t.w, 
        height:t.h, 
        fill: isBlocked ? TAKEN_COLOR : TABLE_COLOR, // Apply color based on time status
        stroke:'#000', 
        strokeWidth:1,
        name: 'main-table' 
      });
      group.add(tableRect);

      // Seat drawing logic (remains the same)
      const baseSeatSize = 12; 
      const seatHalf = baseSeatSize / 2; 
      function makeSeat(x, y, w, h) { group.add(new Konva.Rect({ width:w, height:h, fill:SEAT_COLOR, x:x, y:y })); }
      
      if (t.w === 30 && t.h === 30) { const seatW = baseSeatSize, seatH = seatHalf; makeSeat(t.w/2 - seatW/2, -seatH, seatW, seatH); makeSeat(t.w/2 - seatW/2, t.h, seatW, seatH); } 
      else if (t.w === 30 && t.h === 50) { const seatW = seatHalf, seatH = baseSeatSize; const v_spacing = (t.h - 2*seatH)/3; makeSeat(-seatW, v_spacing, seatW, seatH); makeSeat(-seatW, v_spacing*2 + seatH, seatW, seatH); makeSeat(t.w, v_spacing, seatW, seatH); makeSeat(t.w, v_spacing*2 + seatH, seatW, seatH); } 
      else if (t.w === 90 && t.h === 30) { const seatW = baseSeatSize, seatH = seatHalf; const h_spacing = t.w / 4; for(let i=0; i<3; i++){ const x_pos = h_spacing*(i+1) - seatW/2; makeSeat(x_pos, -seatH, seatW, seatH); makeSeat(x_pos, t.h, seatW, seatH); } }

      group.on('mousedown touchstart', () => {
        if(selectedGroup) selectedGroup.findOne('.main-table').stroke('#000');
        selectedGroup = group;
        tableRect.stroke('#ffeb3b');
        layer.draw();
      });
      return group;
    }

    // --- Update Listeners and Initial Load ---
    
    document.getElementById('view-schedule').onclick = () => {
      loadTables();
    };

    document.getElementById('rotate').onclick = () => {
      if(selectedGroup){
        selectedGroup.rotation(selectedGroup.rotation()+90);
        layer.draw();
      }
    };

    document.getElementById('save').onclick = async () => {
      const updates = tables.map(t=>{
        const g = layer.findOne('#g-'+t.id);
        const tableRect = g.findOne('.main-table');
        const finalX = g.x() - tableRect.width()/2;
        const finalY = g.y() - tableRect.height()/2;
        const finalRotation = g.rotation();
        return { id:t.id, x:finalX, y:finalY, rotation: finalRotation };
      });
      const { data, error } = await _supa.from('tables').upsert(updates).select('*, rotation');
      if(error){ alert('Save failed: '+error.message); } else { tables = data; alert('Layout saved!'); }
    };

    // Initial load sequence
    populateTimeDropdown();
    loadBackground(loadTables);
  </script>
</body>
</html>
```

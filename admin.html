<script>
    // --- Supabase setup ---
    const supabaseUrl = 'https://Rrjvdabtqzkaomjuiref.supabase.co';
    const supabaseAnon = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJyanZkYWJ0cXprYW9tanVpcmVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkxNDM3MzQsImV4cCI6MjA3NDcxOTczNH0.wAEeowZ8Yc8K54jAxEbY-8-mM0OGciMmyz6fJb9Z1Qg';
    const _supa = supabase.createClient(supabaseUrl, supabaseAnon);

    const STAGE_WIDTH = 480;
    const STAGE_HEIGHT = 480;

    const stage = new Konva.Stage({ container:'container', width:STAGE_WIDTH, height:STAGE_HEIGHT });
    const backgroundLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    const layer = new Konva.Layer(); 
    stage.add(layer);

    let tables = [];
    let selectedGroup = null;
    const TABLE_COLOR = '#b7d7a8';
    const BOOKED_COLOR = '#bdbdbd'; // Grey for booked
    const SEAT_COLOR = '#555';
    
    let currentBookings = []; 
    let currentSelectedDate = ''; // Will hold the date 'YYYY-MM-DD'
    let currentSelectedTime = ''; // Will hold the time 'HH:MM'
    let currentSelectedTableId = null; // ID of the table clicked in the modal

    // Helper to get today's date and a default time for inputs
    function setDefaultDateTime() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        
        // Ensure inputs are set with defaults
        currentSelectedDate = `${year}-${month}-${day}`;
        currentSelectedTime = '19:00'; // Default evening time

        document.getElementById('booking-date').value = currentSelectedDate;
        document.getElementById('booking-time').value = currentSelectedTime;
    }

    // --- Konva Functions (unchanged logic for drawing seats) ---

    function loadBackground(callback) {
        const imageObj = new Image();
        imageObj.onload = function() {
            const floorplan = new Konva.Image({
                x: 0, y: 0, image: imageObj, width: STAGE_WIDTH, height: STAGE_HEIGHT,
            });
            backgroundLayer.add(floorplan);
            backgroundLayer.draw();
            if (callback) callback();
        };
        imageObj.src = 'floorplan.png';
    }

    async function loadTables() {
        const { data, error } = await _supa.from('tables').select('*, rotation').order('id');
        if(error){ console.error(error); alert('Error loading tables'); return; }
        tables = data;
        
        layer.destroyChildren(); // Clear existing tables
        tables.forEach(t => {
            const group = drawTable(t);
            const tableRect = group.findOne('.main-table');

            group.offset({ x: tableRect.width()/2, y: tableRect.height()/2 });
            group.x(t.x + tableRect.width()/2);
            group.y(t.y + tableRect.height()/2);
            group.rotation(t.rotation || 0); 
        });
        layer.draw();
        // Initial load of tables, then load bookings based on defaults
        await loadBookings(); 
    }
    
    function updateTableVisuals() {
        tables.forEach(t => {
            const group = layer.findOne('#g-'+t.id);
            if (!group) return;
            const tableRect = group.findOne('.main-table');
            
            // Find the active booking for this table
            const activeBooking = currentBookings.find(b => b.table_id === t.id);
            
            // Store the current booking data on the Konva group for easy access
            group.setAttr('booking_data', activeBooking || null);

            tableRect.fill(activeBooking ? BOOKED_COLOR : TABLE_COLOR);
            layer.draw();
        });
    }

    function drawTable(t){
        const group = new Konva.Group({ x:t.x, y:t.y, id:'g-'+t.id, table_id:t.id, draggable:true });
        layer.add(group);

        const tableRect = new Konva.Rect({ 
            width:t.w, height:t.h, fill:TABLE_COLOR, stroke:'#000', strokeWidth:1, name: 'main-table' 
        });
        group.add(tableRect);

        // ... (Seat drawing logic is the same as before) ...
        const baseSeatSize = 12; 
        const seatHalf = baseSeatSize / 2; 

        function makeSeat(x, y, w, h) {
            group.add(new Konva.Rect({ width:w, height:h, fill:SEAT_COLOR, x:x, y:y }));
        }

        // Seat positions (original logic kept for reference)
        if (t.w === 30 && t.h === 30) { // 2-seater
            makeSeat(t.w/2 - baseSeatSize/2, -seatHalf, baseSeatSize, seatHalf);
            makeSeat(t.w/2 - baseSeatSize/2, t.h, baseSeatSize, seatHalf);
        } else if (t.w === 30 && t.h === 50) { // 4-seater
            const v_spacing = (t.h - 2*baseSeatSize)/3;
            makeSeat(-seatHalf, v_spacing, seatHalf, baseSeatSize);
            makeSeat(-seatHalf, v_spacing*2 + baseSeatSize, seatHalf, baseSeatSize);
            makeSeat(t.w, v_spacing, seatHalf, baseSeatSize);
            makeSeat(t.w, v_spacing*2 + baseSeatSize, seatHalf, baseSeatSize);
        } else if (t.w === 90 && t.h === 30) { // 6-seater
            const h_spacing = t.w / 4;
            for(let i=0; i<3; i++){
                const x_pos = h_spacing*(i+1) - baseSeatSize/2;
                makeSeat(x_pos, -seatHalf, baseSeatSize, seatHalf);
                makeSeat(x_pos, t.h, baseSeatSize, seatHalf);
            }
        }

        // --- Left-Click (Standard Select & Booking Modal) ---
        group.on('click', () => {
            if(selectedGroup) selectedGroup.findOne('.main-table').stroke('#000');
            selectedGroup = group;
            tableRect.stroke('#ffeb3b');
            layer.draw();
            
            currentSelectedTableId = t.id;
            showBookingModal(t.id, group.getAttr('booking_data')); // Pass booking data to modal
        });
        
        // --- Right-Click (Unreserve Feature) ---
        group.on('contextmenu', (e) => {
            e.evt.preventDefault(); // Prevent browser context menu
            const booking = group.getAttr('booking_data');
            
            if (booking) {
                if (confirm(`Table ${t.id} is booked. Do you want to cancel the booking (ID: ${booking.id}) for ${booking.start_time} - ${booking.end_time} on ${booking.date}?`)) {
                    deleteBooking(booking.id);
                }
            } else {
                alert(`Table ${t.id} is currently available at ${currentSelectedTime} on ${currentSelectedDate}.`);
            }
        });
        
        return group;
    }
    
    // --- Supabase Booking Functions ---
    
    async function loadBookings() {
        currentSelectedDate = document.getElementById('booking-date').value;
        currentSelectedTime = document.getElementById('booking-time').value;

        if (!currentSelectedDate || !currentSelectedTime) {
            console.log("Date and time not selected. Skipping booking load.");
            currentBookings = [];
            updateTableVisuals();
            return;
        }
        
        // Fetch bookings for the selected date
        // Note: The logic for time overlap must be implemented manually since we have separate date/time columns.
        const { data, error } = await _supa
            .from('premium_slots') // *** UPDATED TABLE NAME ***
            .select('*')
            .eq('date', currentSelectedDate);
            
        if(error){ 
            console.error('Error loading bookings:', error); 
            alert('Error loading bookings'); 
            currentBookings = []; 
        } else { 
            // Client-side filtering for bookings active at the selected time
            // The selected time must be >= booking start_time AND < booking end_time
            currentBookings = data.filter(b => {
                const selectedTime = currentSelectedTime; // HH:MM
                const bookingStart = b.start_time;       // HH:MM:SS
                const bookingEnd = b.end_time;           // HH:MM:SS
                
                // Compare times as strings (HH:MM is comparable to HH:MM:SS)
                return selectedTime >= bookingStart && selectedTime < bookingEnd;
            });
        }
        
        updateTableVisuals();
    }
    
    async function createBooking(tableId, startTime, endTime, notes) {
        const date = document.getElementById('booking-date').value;
        
        // Basic time validation
        if (endTime <= startTime) {
            alert('End time must be after start time.');
            return false;
        }

        // Check for overlap using the client-side array
        const overlap = currentBookings.some(b => 
            b.table_id === tableId && (
                // Overlap: The new start is before the existing end AND the new end is after the existing start
                (startTime < b.end_time && endTime > b.start_time)
            )
        );
        
        if (overlap) {
             alert('This slot overlaps with an existing booking. Please try a different time.');
             return false;
        }
        
        const newBooking = {
            table_id: tableId,
            date: date, // YYYY-MM-DD
            start_time: startTime, // HH:MM
            end_time: endTime, // HH:MM
            host_notes: notes, // *** UPDATED COLUMN NAME ***
        };

        const { error } = await _supa.from('premium_slots').insert([newBooking]); // *** UPDATED TABLE NAME ***
        
        if (error) {
            console.error('Error creating booking:', error);
            alert('Booking failed: ' + error.message);
            return false;
        } else {
            alert('Booking successful!');
            return true;
        }
    }
    
    async function deleteBooking(bookingId) {
        const { error } = await _supa
            .from('premium_slots') // *** UPDATED TABLE NAME ***
            .delete()
            .eq('id', bookingId);
        
        if (error) {
            console.error('Error deleting booking:', error);
            alert('Deletion failed: ' + error.message);
            return false;
        } else {
            // Success: close modal and refresh
            modal.style.display = 'none';
            await loadBookings();
            return true;
        }
    }

    // --- Modal/UI Functions ---
    
    const modal = document.getElementById('booking-modal');
    const closeModal = document.querySelector('.close-button');
    const removeBookingButton = document.getElementById('remove-booking');
    
    closeModal.onclick = () => { modal.style.display = 'none'; };
    window.onclick = (event) => { if (event.target == modal) { modal.style.display = 'none'; } };
    
    function showBookingModal(tableId, booking) {
        document.getElementById('modal-table-id').value = tableId;
        document.getElementById('modal-title').textContent = 'Table ' + tableId + ' Booking';
        
        if (booking) {
            // BOOKED STATE
            document.getElementById('current-booking-info').style.display = 'block';
            document.getElementById('new-booking-form').style.display = 'none';
            
            // Populate booked info
            document.getElementById('booked-start').textContent = booking.start_time.substring(0, 5);
            document.getElementById('booked-end').textContent = booking.end_time.substring(0, 5);
            document.getElementById('booked-notes').textContent = booking.host_notes || 'None'; // *** UPDATED COLUMN NAME ***
            
            // Set up removal button action
            removeBookingButton.onclick = async () => {
                if (confirm('Are you sure you want to remove this booking?')) {
                    await deleteBooking(booking.id);
                }
            };
        } else {
            // AVAILABLE STATE
            document.getElementById('current-booking-info').style.display = 'none';
            document.getElementById('new-booking-form').style.display = 'block';
            
            // Pre-fill times with the selected time range (e.g., 1 hour slot)
            document.getElementById('start-time').value = currentSelectedTime;
            
            // Calculate end time (e.g., +1 hour)
            const [h, m] = currentSelectedTime.split(':').map(Number);
            const endDate = new Date();
            endDate.setHours(h);
            endDate.setMinutes(m);
            endDate.setHours(endDate.getHours() + 1);
            
            const endH = String(endDate.getHours()).padStart(2, '0');
            const endM = String(endDate.getMinutes()).padStart(2, '0');

            document.getElementById('end-time').value = `${endH}:${endM}`;
            document.getElementById('notes').value = '';
        }
        
        modal.style.display = 'block';
    }

    // --- Event Listeners ---

    document.getElementById('load-bookings').onclick = async () => {
        // Re-read date and time from inputs on button click
        currentSelectedDate = document.getElementById('booking-date').value;
        currentSelectedTime = document.getElementById('booking-time').value;
        await loadBookings();
    };

    document.getElementById('booking-form').onsubmit = async (e) => {
        e.preventDefault();
        const tableId = parseInt(document.getElementById('modal-table-id').value);
        const startTime = document.getElementById('start-time').value;
        const endTime = document.getElementById('end-time').value;
        const notes = document.getElementById('notes').value;

        const success = await createBooking(tableId, startTime, endTime, notes);
        if (success) {
            modal.style.display = 'none';
            await loadBookings(); // Reload visuals after successful booking
        }
    };


    document.getElementById('rotate').onclick = () => {
        if(selectedGroup){
            selectedGroup.rotation(selectedGroup.rotation()+90);
            layer.draw();
        }
    };

    document.getElementById('save').onclick = async () => {
        const updates = tables.map(t=>{
            const g = layer.findOne('#g-'+t.id);
            const tableRect = g.findOne('.main-table');
            const finalX = g.x() - tableRect.width()/2;
            const finalY = g.y() - tableRect.height()/2;
            const finalRotation = g.rotation();
            return { id:t.id, x:finalX, y:finalY, rotation: finalRotation };
        });
        const { data, error } = await _supa.from('tables').upsert(updates).select('*, rotation');
        if(error){ alert('Save failed: '+error.message); } else { tables = data; alert('Layout saved!'); }
    };

    // --- Initialization ---
    setDefaultDateTime();
    loadBackground(loadTables);
</script>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Admin – Drag Tables & Bookings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    body{
        font-family: Arial, Helvetica, sans-serif;
        background:#f7f7f7;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
        margin: 0;
        padding: 20px 0;
    }

    /* Header container */
    h2 {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 700;
      color: #333;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 10px;
    }

    h2 .arrow {
      font-weight: 700;
      font-size: 24px;
      margin: 0 10px;
      color: #1976d2;
    }

    /* Buttons in header */
    h2 button {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      color: #fff;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }

    h2 button#save {
      background-color: #388e3c;
    }
    h2 button#rotate {
      background-color: #1976d2;
    }

    h2 button:hover {
      box-shadow: 0 6px 14px rgba(0,0,0,0.3);
      opacity: 0.95;
    }

    #controls {
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:12px;
      flex-wrap:wrap;
    }

    #container-wrapper {
      display: flex;
      justify-content: center;
      width: 100%;
    }

    #container{
      width:480px;
      height:480px;
      border:1px solid #ccc;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      background:#fff;
    }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal {
      background: white;
      width: 420px;
      max-width: calc(100% - 40px);
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .modal h3 { margin: 0 0 12px 0; font-size: 18px; }
    .modal label { display:block; font-size:13px; margin-top:8px; }
    .modal input[type="datetime-local"],
    .modal textarea, .modal input[type="text"] {
      width:100%; padding:8px; margin-top:6px; border-radius:6px; border:1px solid #ddd; box-sizing:border-box;
    }
    .modal textarea{ min-height:80px; resize:vertical; }
    .modal .row { display:flex; gap:8px; }
    .modal .row .col { flex:1; }
    .modal .actions { display:flex; gap:8px; margin-top:12px; justify-content:flex-end; }
    .btn { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }
    .btn.primary { background:#1976d2; color:white; }
    .btn.negative { background:#d32f2f; color:white; }
    .btn.ghost { background:#f2f2f2; color:#333; }

    /* Responsive */
    @media (max-width: 500px) {
      h2 { font-size: 18px; }
      h2 button { padding: 8px 14px; font-size: 14px; }
      #controls { flex-direction: column; align-items:flex-start; gap:8px; }
    }
  </style>
</head>

<body>
  <h2>
    Drag tables <span class="arrow">→</span>
    <button id="save">Save layout</button>
    <button id="rotate">Rotate Table 90°</button>
  </h2>

  <div id="controls">
    <div style="display:flex; gap:8px; align-items:center;">
      <label for="viewDate">View date</label>
      <input id="viewDate" type="date" />
      <label for="viewTime">Time</label>
      <input id="viewTime" type="time" />
      <button id="loadFloorplan" class="btn primary">Load</button>
    </div>
    <div style="margin-left:8px; color:#666; font-size:13px;">
      Select a date/time and click a table to book or view booking.
    </div>
  </div>

  <div id="container-wrapper">
      <div id="container"></div>
  </div>

  <!-- Modal backdrop -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" id="bookingModal">
      <!-- Content injected by JS -->
    </div>
  </div>

  <script>
    // --- Supabase setup ---
    const supabaseUrl = 'https://Rrjvdabtqzkaomjuiref.supabase.co';
    const supabaseAnon = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJyanZkYWJ0cXprYW9tanVpcmVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkxNDM3MzQsImV4cCI6MjA3NDcxOTczNH0.wAEeowZ8Yc8K54jAxEbY-8-mM0OGciMmyz6fJb9Z1Qg';
    const _supa = supabase.createClient(supabaseUrl, supabaseAnon);

    const STAGE_WIDTH = 480;
    const STAGE_HEIGHT = 480;

    const stage = new Konva.Stage({ container:'container', width:STAGE_WIDTH, height:STAGE_HEIGHT });
    const backgroundLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    const layer = new Konva.Layer();
    stage.add(layer);

    let tables = [];
    let bookingsCache = []; // bookings for current selected view datetime (all bookings that overlap that datetime)
    let selectedGroup = null;
    const TABLE_COLOR = '#b7d7a8';
    const SEAT_COLOR = '#555';
    const BOOKED_COLOR = '#cccccc';

    // default view datetime -> now (local)
    function setDefaultViewInputs() {
      const now = new Date();
      const pad = (n) => n.toString().padStart(2,'0');
      const yyyy = now.getFullYear();
      const mm = pad(now.getMonth()+1);
      const dd = pad(now.getDate());
      const hh = pad(now.getHours());
      const mi = pad(now.getMinutes());
      document.getElementById('viewDate').value = `${yyyy}-${mm}-${dd}`;
      document.getElementById('viewTime').value = `${hh}:${mi}`;
    }
    setDefaultViewInputs();

    function showModal(htmlContent) {
      const backdrop = document.getElementById('modalBackdrop');
      const modal = document.getElementById('bookingModal');
      modal.innerHTML = htmlContent;
      backdrop.style.display = 'flex';
      backdrop.setAttribute('aria-hidden', 'false');
    }
    function closeModal() {
      const backdrop = document.getElementById('modalBackdrop');
      backdrop.style.display = 'none';
      backdrop.setAttribute('aria-hidden', 'true');
    }

    // load background floorplan image (if present)
    function loadBackground(callback) {
      const imageObj = new Image();
      imageObj.onload = function() {
        backgroundLayer.destroyChildren();
        const floorplan = new Konva.Image({
          x: 0,
          y: 0,
          image: imageObj,
          width: STAGE_WIDTH,
          height: STAGE_HEIGHT,
        });
        backgroundLayer.add(floorplan);
        backgroundLayer.draw();
        if (callback) callback();
      };
      // If floorplan.png missing, image load will error quietly; still proceed
      imageObj.src = 'floorplan.png';
      imageObj.onerror = function(){ if (callback) callback(); };
    }

    // Draw a table group from table record object t
    function drawTable(t) {
      const group = new Konva.Group({ x:t.x || 0, y:t.y || 0, id:'g-'+t.id, draggable:true });
      layer.add(group);

      const tableRect = new Konva.Rect({
        width:t.w,
        height:t.h,
        fill: TABLE_COLOR,
        stroke:'#000',
        strokeWidth:1,
        name: 'main-table'
      });
      group.add(tableRect);

      const baseSeatSize = 12;
      const seatHalf = baseSeatSize / 2;

      function makeSeat(x, y, w, h) {
        group.add(new Konva.Rect({ width:w, height:h, fill:SEAT_COLOR, x:x, y:y }));
      }

      // Seat positions based on dims
      if (t.w === 30 && t.h === 30) { // 2-seater
        makeSeat(t.w/2 - baseSeatSize/2, -seatHalf, baseSeatSize, seatHalf);
        makeSeat(t.w/2 - baseSeatSize/2, t.h, baseSeatSize, seatHalf);
      } else if (t.w === 30 && t.h === 50) { // 4-seater
        const v_spacing = (t.h - 2*baseSeatSize)/3;
        makeSeat(-seatHalf, v_spacing, seatHalf, baseSeatSize);
        makeSeat(-seatHalf, v_spacing*2 + baseSeatSize, seatHalf, baseSeatSize);
        makeSeat(t.w, v_spacing, seatHalf, baseSeatSize);
        makeSeat(t.w, v_spacing*2 + baseSeatSize, seatHalf, baseSeatSize);
      } else if (t.w === 90 && t.h === 30) { // 6-seater
        const h_spacing = t.w / 4;
        for(let i=0; i<3; i++){
          const x_pos = h_spacing*(i+1) - baseSeatSize/2;
          makeSeat(x_pos, -seatHalf, baseSeatSize, seatHalf);
          makeSeat(x_pos, t.h, baseSeatSize, seatHalf);
        }
      }

      // clickable behavior (will be set/extended in loadTables)
      group.on('click', () => {
        // selection visual
        if(selectedGroup) {
          const prevRect = selectedGroup.findOne('.main-table');
          if (prevRect) prevRect.stroke('#000');
        }
        selectedGroup = group;
        tableRect.stroke('#ffeb3b');
        layer.draw();

        // manage booking modal in loadTables (we will set group.meta when creating them)
        if (group.meta && typeof group.meta.onClick === 'function') {
          group.meta.onClick();
        }
      });

      return group;
    }

    // Helper: format date for display
    function fmtLocalISO(dt) {
      // returns "YYYY-MM-DDTHH:MM" (suitable for datetime-local)
      const pad = n=>String(n).padStart(2,'0');
      return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())}T${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
    }

    // Load tables and mark bookings for a given selectedDateTime (JS Date)
    async function loadTables(selectedDateTime) {
      if (!selectedDateTime || !(selectedDateTime instanceof Date)) {
        alert('Invalid date/time selected.');
        return;
      }

      layer.destroyChildren();
      // reload background first
      loadBackground();

      // load tables from supabase
      const { data: tableData, error: tableErr } = await _supa.from('tables').select('*').order('id');
      if (tableErr) { console.error(tableErr); alert('Error loading tables'); return; }
      tables = tableData || [];

      // Query bookings where start_time <= selectedDateTime AND end_time >= selectedDateTime
      const dtISO = selectedDateTime.toISOString();
      const { data: bookingData, error: bookingErr } = await _supa
        .from('bookings')
        .select('*')
        .lte('start_time', dtISO)
        .gte('end_time', dtISO);

      if (bookingErr) {
        console.error('Error loading bookings: ', bookingErr);
      }
      bookingsCache = bookingData || [];

      // Draw tables and mark those booked
      tables.forEach(t => {
        const group = drawTable(t);
        const tableRect = group.findOne('.main-table');

        // place group centered on table coordinate like before
        group.offset({ x: tableRect.width()/2, y: tableRect.height()/2 });
        group.x((t.x || 0) + tableRect.width()/2);
        group.y((t.y || 0) + tableRect.height()/2);
        group.rotation(t.rotation || 0);

        // determine if this table is booked at selectedDateTime
        const booking = bookingsCache.find(b => b.table_id === t.id);
        if (booking) {
          tableRect.fill(BOOKED_COLOR);
          group.draggable(false);
          group.isBooked = true;
          group.booking = booking;
        } else {
          tableRect.fill(TABLE_COLOR);
          group.draggable(true);
          group.isBooked = false;
          group.booking = null;
        }

        // attach meta click handler to open booking modal
        group.meta = {
          table: t,
          onClick: () => openBookingFlowForGroup(group)
        };
      });

      layer.draw();
    }

    // booking overlap check (client-side)
    async function hasOverlap(tableId, startISO, endISO) {
      // fetch bookings for this table and check overlap
      const { data: existing, error } = await _supa
        .from('bookings')
        .select('*')
        .eq('table_id', tableId);

      if (error) {
        console.error('Error fetching bookings for overlap check', error);
        throw error;
      }

      const newStart = new Date(startISO);
      const newEnd = new Date(endISO);
      for (const b of (existing || [])) {
        const s = new Date(b.start_time);
        const e = new Date(b.end_time);
        // overlap if newStart < e AND newEnd > s
        if (newStart < e && newEnd > s) return true;
      }
      return false;
    }

    // attempt to create booking
    async function bookTable(tableId, startISO, endISO, notes) {
      // validation
      const start = new Date(startISO);
      const end = new Date(endISO);
      if (isNaN(start) || isNaN(end) || end <= start) {
        alert('Invalid start/end times.');
        return { success:false };
      }

      // prevent overlaps
      const overlap = await hasOverlap(tableId, startISO, endISO);
      if (overlap) {
        return { success:false, message: 'Time overlaps an existing booking for that table.' };
      }

      const { data, error } = await _supa.from('bookings').insert([
        { table_id: tableId, start_time: start.toISOString(), end_time: end.toISOString(), notes }
      ]).select('*');

      if (error) {
        console.error('Booking failed', error);
        return { success:false, message: error.message || 'Booking failed' };
      }

      return { success:true, booking: (data && data[0]) || null };
    }

    // delete a booking by id
    async function removeBooking(bookingId) {
      const { data, error } = await _supa.from('bookings').delete().eq('id', bookingId);
      if (error) {
        return { success:false, message: error.message };
      }
      return { success:true };
    }

    // Open booking flow modal for a group (either show booking form if free, or show booking details if booked)
    function openBookingFlowForGroup(group) {
      const t = group.meta.table;
      const viewDate = document.getElementById('viewDate').value;
      const viewTime = document.getElementById('viewTime').value;
      const viewDateTime = viewDate && viewTime ? new Date(`${viewDate}T${viewTime}`) : new Date();

      if (group.isBooked && group.booking) {
        // show booking details and delete option
        const bk = group.booking;
        const start = new Date(bk.start_time);
        const end = new Date(bk.end_time);
        const modalHtml = `
          <h3>Booking for Table #${t.id}</h3>
          <div><strong>Start:</strong> ${start.toLocaleString()}</div>
          <div><strong>End:</strong> ${end.toLocaleString()}</div>
          <div style="margin-top:8px;"><strong>Notes:</strong><div style="margin-top:6px; padding:8px; background:#f6f6f6; border-radius:6px;">${escapeHtml(bk.notes || '')}</div></div>
          <div class="actions">
            <button class="btn ghost" id="closeModalBtn">Close</button>
            <button class="btn negative" id="deleteBookingBtn">Remove Booking</button>
          </div>
        `;
        showModal(modalHtml);
        document.getElementById('closeModalBtn').onclick = closeModal;
        document.getElementById('deleteBookingBtn').onclick = async () => {
          if (!confirm('Remove this booking?')) return;
          const res = await removeBooking(bk.id);
          if (!res.success) {
            alert('Failed to remove booking: ' + (res.message || 'unknown'));
            return;
          }
          closeModal();
          // reload current view
          loadCurrentView();
        };
        return;
      }

      // not booked -> show booking form. Prefill start/end around viewDateTime
      const defaultStart = new Date(viewDateTime);
      defaultStart.setMinutes( Math.ceil(defaultStart.getMinutes()/15)*15 ); // round to 15min
      const defaultEnd = new Date(defaultStart.getTime() + 60*60*1000); // +1h

      const modalHtml = `
        <h3>Book Table #${t.id}</h3>
        <label>Start</label>
        <input id="b_start" type="datetime-local" value="${fmtLocalISO(defaultStart)}" />
        <label>End</label>
        <input id="b_end" type="datetime-local" value="${fmtLocalISO(defaultEnd)}" />
        <label>Notes</label>
        <textarea id="b_notes" placeholder="Optional notes"></textarea>
        <div class="actions">
          <button class="btn ghost" id="cancelBookingBtn">Cancel</button>
          <button class="btn primary" id="confirmBookingBtn">Book</button>
        </div>
      `;
      showModal(modalHtml);
      document.getElementById('cancelBookingBtn').onclick = closeModal;
      document.getElementById('confirmBookingBtn').onclick = async () => {
        const startVal = document.getElementById('b_start').value;
        const endVal = document.getElementById('b_end').value;
        const notes = document.getElementById('b_notes').value || '';
        if (!startVal || !endVal) { alert('Start and end required'); return; }
        if (new Date(endVal) <= new Date(startVal)) { alert('End must be after start'); return; }

        // attempt booking
        const result = await bookTable(t.id, new Date(startVal).toISOString(), new Date(endVal).toISOString(), notes);
        if (!result.success) {
          alert(result.message || 'Booking failed (possible overlap)');
          return;
        }
        closeModal();
        loadCurrentView(); // refresh floorplan for the same view time
        alert('Booked!');
      };
    }

    // Escape HTML for display in modal
    function escapeHtml(unsafe) {
      return String(unsafe).replace(/[&<"'>]/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
      });
    }

    // Load the floorplan for selected view controls
    function loadCurrentView() {
      const date = document.getElementById('viewDate').value;
      const time = document.getElementById('viewTime').value;
      if (!date || !time) { alert('Pick a date and time first'); return; }
      const dt = new Date(`${date}T${time}`);
      loadTables(dt);
    }

    // Save current layout: update tables positions/rotation
    document.getElementById('save').onclick = async () => {
      try {
        const updates = tables.map(t=>{
          const g = layer.findOne('#g-'+t.id);
          if (!g) return null;
          const tableRect = g.findOne('.main-table');
          // compute top-left from centered group coordinates
          const finalX = g.x() - tableRect.width()/2;
          const finalY = g.y() - tableRect.height()/2;
          const finalRotation = g.rotation();
          return { id:t.id, x: Math.round(finalX), y: Math.round(finalY), rotation: Math.round(finalRotation) };
        }).filter(Boolean);

        if (updates.length === 0) { alert('No tables to save'); return; }
        const { data, error } = await _supa.from('tables').upsert(updates).select('*');
        if (error) { alert('Save failed: ' + (error.message || 'unknown')); return; }
        // refresh tables list
        tables = data;
        alert('Layout saved!');
      } catch (err) {
        console.error(err);
        alert('Save failed: ' + err.message);
      }
    };

    // Rotate selected table 90 degrees
    document.getElementById('rotate').onclick = () => {
      if(selectedGroup){
        selectedGroup.rotation((selectedGroup.rotation() + 90) % 360);
        layer.draw();
      } else {
        alert('Select a table first (click it).');
      }
    };

    document.getElementById('loadFloorplan').onclick = loadCurrentView;

    // close modal when clicking backdrop
    document.getElementById('modalBackdrop').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) closeModal();
    });

    // initial load: draw background and load tables at default datetime
    (async function init(){
      loadBackground();
      // attempt to load for default view inputs
      loadCurrentView();
    })();
  </script>
</body>
</html>
